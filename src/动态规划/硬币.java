package 动态规划;
//知耻而后勇，知弱而图强
//给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
//
//        示例1:
//
//        输入: n = 5
//        输出：2
//        解释: 有两种方式可以凑成总金额:
//        5=5
//        5=1+1+1+1+1
//        示例2:
//
//        输入: n = 10
//        输出：4
//        解释: 有四种方式可以凑成总金额:
//        10=10
//        10=5+5
//        10=5+1+1+1+1+1
//        10=1+1+1+1+1+1+1+1+1+1
//        说明：
//
//        注意:
//
//        你可以假设：
//
//        0 <= n (总金额) <= 1000000
public class 硬币 {
    //动态规划，完全背包问题
    //dp[i][j]表示从前i种硬币中，选取若干个硬币，使他们金额之和达到j的方案数
    //状态转移方程： dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]]
    //1.dp[i-1][j]表示不选取第i种硬币所组成金额为j的方案
    //2.dp[i][j-coins[i-1]]表示至少选取一个第第i种硬币所组成金额为j的方案
    public int waysToChange(int n) {
        int[] coins={1,5,10,25};
        int[][] dp=new int[5][n+1];
        for (int i=0;i<dp.length;i++){
            dp[i][0]=1;
        }
        for (int i=1;i<dp.length;i++){
            for (int j=1;j<=n;j++){
                //默认不选择当前种类硬币所能达到j金额的组成数量
                dp[i][j]=dp[i-1][j]%1000000007;
                //如果当前金币的额度超过金额，则不选择当前种类硬币
                if (j>=coins[i-1]){
                    dp[i][j]=(dp[i-1][j]+dp[i][j-coins[i-1]])%1000000007;
                }
            }
        }
        return dp[4][n];
    }

    //空间优化，因为dp[i][j]只和dp[i-1][j]和dp[i][j-coins[i-1]有关，所以从左往右遍历
    public int waysToChangeBetter(int n) {
        int[] coins={1,5,10,25};
        int[] dp=new int[n+1];
        dp[0]=1;
        for (int i=1;i<dp.length;i++){
            for (int j=1;j<=n;j++){
                //如果当前金币的额度超过金额，则不选择当前种类硬币
                if (j>=coins[i-1]){
                    dp[j]=(dp[j]+dp[j-coins[i-1]])%1000000007;
                }
            }
        }
        return dp[n];
    }
}
